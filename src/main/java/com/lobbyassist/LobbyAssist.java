package com.lobbyassist;

import com.lobbyassist.model.StunAck;
import com.lobbyassist.net.packet.CaptureTask;
import com.lobbyassist.net.packet.StunPacket;
import com.lobbyassist.ui.Overlay;
import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableMap;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ChoiceBox;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import org.pcap4j.core.*;
import org.pcap4j.packet.Packet;

import java.net.InetAddress;
import java.util.HashMap;
import java.util.Map;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class LobbyAssist extends Application{

    private Map<Integer, StunAck> tracking = new HashMap<Integer, StunAck>();
    private ObservableMap<Integer, Long> pings = FXCollections.observableHashMap();

    private double xOffset = 0;
    private double yOffset = 0;

    private CaptureTask<Void> captureTask;

    public static void main (String[] args) {
        launch(args);
    }

    @Override
    public void start (Stage primaryStage) {
        Text title = new Text("LobbyAssist");
        title.getStyleClass().add("title");
        Region region = new Region();

        Button close = new Button("X");
        close.setOnMouseClicked(event -> Platform.exit());

        Button minimize = new Button("\u2014");
        minimize.setOnMouseClicked(event -> primaryStage.setIconified(true));


        HBox top = new HBox();
        top.setAlignment(Pos.CENTER_LEFT);
        top.getChildren().addAll(title, region, minimize, close);
        top.getStyleClass().add("top-menu");
        HBox.setHgrow(region, Priority.ALWAYS);

        BorderPane pane = new BorderPane();
        pane.getStyleClass().add("main-pane");
        pane.setTop(top);

        pane.setOnMousePressed(event -> {
            xOffset = event.getSceneX();
            yOffset = event.getSceneY();
        });

        pane.setOnMouseDragged(event -> {
            primaryStage.setX(event.getScreenX() - xOffset);
            primaryStage.setY(event.getScreenY() - yOffset);
        });

        pane.setCenter(devices());

        Scene scene = new Scene(pane);
        scene.setFill(Color.TRANSPARENT);
        scene.getStylesheets().add(getClass().getResource("/styles.css").toExternalForm());

        Overlay overlay = new Overlay(pings);

        primaryStage.setScene(scene);
        primaryStage.initStyle(StageStyle.UNDECORATED);
        primaryStage.setAlwaysOnTop(true);
        primaryStage.setResizable(false);
        primaryStage.show();
    }

    private HBox devices () {
        HBox box = new HBox();
        box.getStyleClass().add("hbox");

        ChoiceBox<InetAddress> choices = new ChoiceBox<>(FXCollections.observableArrayList());

        try {
            for (PcapNetworkInterface pni : Pcaps.findAllDevs()) {
                for (PcapAddress address : pni.getAddresses()) {
                    if (address.getNetmask() != null) {
                        choices.getItems().add(address.getAddress());
                    }
                }
            }
        } catch (PcapNativeException e) {
            e.printStackTrace();
        }

        choices.setMaxWidth(Double.MAX_VALUE);

        Button accept = new Button("Listen");

        accept.setOnMouseClicked(event -> {
            InetAddress choice = choices.getValue();

            if (choice != null) {
                if (captureTask != null && captureTask.isRunning()) {
                    captureTask.cancel();
                }
                captureTask = new CaptureTask<>(choice, pings);
                Thread thread = new Thread(captureTask);
                thread.setDaemon(true);
                thread.start();
            }
        });

        box.getChildren().addAll(choices, accept);
        HBox.setHgrow(choices, Priority.ALWAYS);

        return box;
    }
}
